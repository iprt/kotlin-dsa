# 动态规划

> DP is just a kind of smart recursion

<!-- TOC -->

* [动态规划](#动态规划)
  * [基础示例](#基础示例)
  * [记忆化搜索](#记忆化搜索)
  * [背包DP](#背包dp)
    * [引入](#引入)
    * [0-1背包](#0-1背包)
    * [完全背包](#完全背包)
    * [混合背包](#混合背包)
    * [二维费用背包](#二维费用背包)
    * [分组背包](#分组背包)
    * [有依赖的背包](#有依赖的背包)
    * [泛化物品背包](#泛化物品背包)

<!-- TOC -->

## 基础示例

[数字三角形](src/main/kotlin/io/intellij/dsa/dp/NumberTriangles.kt)

给定一个 r 行的数字三角形（r <= 1000），需要找到一条从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到当前点左下方的点或右下方的点。

```text
        7 
      3   8 
    8   1   0 
  2   7   4   4 
4   5   2   6   5 
```

在上面这个例子中，最优路径是 `7 -> 8 -> 1 -> 7 -> 5`，其和为 `30`。

[link](https://www.luogu.com.cn/problem/P1216)
写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。

**输入格式**

```text
第一个行一个正整数 r，表示行的数目。

后面每行为这个数字金字塔特定行包含的整数。
```

**输出格式**

```text
单独的一行,包含那个可能得到的最大的和。
```

**输入输出样例**

输入

```text
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5 
```

输出

```text
30
```

## 记忆化搜索

记忆化搜索是一种通过记录已经遍历过的状态的信息，从而避免对同一状态重复遍历的搜索实现方式。

因为记忆化搜索确保了每个状态只访问一次，它也是一种常见的动态规划实现方式。

## 背包DP

### 引入

有 $n$ 个物品和一个容量为 $W$ 的背包，每个物品有重量 $w_{i}$ 和价值 $v_i$ 两种属性，要求选若干物品放入背包使背包中物品的总价值最大且背包中物品的总重量不超过背包的容量。

由于每个物体只有两种可能的状态（取与不取），对应二进制中的 0 和 1，这类问题便被称为「0-1 背包问题」。

### 0-1背包

**解释**

例题中已知条件有第 $i$ 个物品的重量 $w_{i}$，价值 $v_{i}$，以及背包的总容量 $W$

设：DP 状态 $f_{i,j}$ 为在只能放前 $i$ 个物品的情况下，容量为 $j$ 的背包所能达到的最大总价值

考虑转移。 假设当前已经处理好了前 $i-1$ 个物品的所有状态，那么对于第 $i$ 个物品，

- 当其不放入背包时，背包的剩余容量不变，背包中物品的总价值也不变，故这种情况的最大价值为 $f_{i-1,j}$；
- 当其放入背包时，背包的剩余容量会减小 $w_{i}$，背包中物品的总价值会增大 $v_{i}$
  ，故这种情况的最大价值为 $f_{i-1,j-w_{i}}+v_{i}$。

由此可以得出状态转移方程：

$$
f_{i,j} = \max(f_{i-1,j}, f_{i-1,j-w_{i}} + v_{i})
$$

> 这里如果直接采用二维数组对状态进行记录，会出现 MLE。可以考虑改用滚动数组的形式来优化。

由于对 $f_i$ 有影响的只有 $f_{i-1}$，可以去掉第一维，直接用 $f_{i}$ 来表示处理到当前物品时背包容量为 $i$ 的最大价值，得出以下方程：

$$
f_{j} = \max(f_{j}, f_{j-w_{i}} + v_{i})
$$

_务必牢记并理解这个转移方程，因为大部分背包问题的转移方程都是在此基础上推导出来的_

### 完全背包

TODO

### 混合背包

TODO

### 二维费用背包

TODO

### 分组背包

TODO

### 有依赖的背包

TODO

### 泛化物品背包

